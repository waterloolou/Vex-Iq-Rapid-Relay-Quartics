{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nleft_motor = Motor(Ports.PORT9, False)\nright_motor = Motor(Ports.PORT3, True)\n\n\n\n# generating and setting random seed\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    systemTime = brain.timer.system() * 100\n    urandom.seed(int(xaxis + yaxis + zaxis + systemTime)) \n    \n# Initialize random seed \ninitializeRandomSeed()\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      PID Test Control\n# \tAuthor:       Louis Cottenier\n# \tCreated:      11/9/2024\n# \tDescription:  Testing PID control\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\nstart_intake = Event()\nstop_intake = Event()\ncatapult_load = Event()\ncatapult_launch = Event()\nerror = 0\noutput = 0\nerror_total = 0\nlast_error = 0\nderivative = 0\ngear_ratio = 2 / 1\n\ndef move(left_speed, right_speed):\n    left_motor.set_velocity(left_speed, PERCENT)\n    right_motor.set_velocity(right_speed, PERCENT)\n    left_motor.spin(FORWARD)\n    right_motor.spin(FORWARD)\n#(gear_ratio * 200)\ndef drivestrait_PID(target_distance, speed, kp, kd, ki, target_heading):\n    left_motor.set_stopping(BRAKE)\n    right_motor.set_stopping(BRAKE)\n    left_motor.set_position(0, DEGREES)\n    right_motor.set_position(0, DEGREES)\n    error_total = brain_inertial.rotation() - target_heading\n    while math.fabs(left_motor.position(DEGREES)) + math.fabs(right_motor.position(DEGREES)) / 2 < target_distance:\n        error = brain_inertial.rotation() - target_heading\n        last_error = error\n        wait(0.2, SECONDS)\n        error = brain_inertial.rotation() - target_heading\n        derivative = error - last_error\n        # + 0.5\n        output = error * kp + (derivative * kd * error_total * ki)\n        move(speed-output, speed + output)\n        error_total = error_total + error\n        wait(20, MSEC)\n    left_motor.stop()\n    right_motor.stop()\n\n\n\n\nturn: Turn drive train in place by a certain angle \nyaw: the angle to move by. \n \ndef turn(yaw):  \n    print(\"++++++\") \n    # set gyro yaw reference to 0\n    brain_inertial.set_rotation(0, DEGREES)  \n    wait(20, MSEC)  \n\n    # compute the error between the desired yaw and the measured yaw\n    error = yaw - brain_inertial.rotation()  \n    wait(20, MSEC)  \n\n    #iterate while the yaw error is greater than 1 degree\n    while math.fabs(error) > 1:  \n        #print(\"gyro rotation: \" + str(gyro_9.rotation()))  \n        #print(\"error: \", error) \n        # set the velocity proportionally to the yaw error to avoid overshooting because of momentum\n        # if the yaw error is large, we can turn quickly\n        # if the yaw error is small, we need to slow down\n        # we set a lower bound on the velocity to make sure we keep moving when the error is very small\n        velocity = math.fabs(error) * (50 / 180)  \n        if velocity < 10:  \n            velocity = 10  \n\n        #print(\"set velocity to: \", velocity)  \n        # set motor velocity\n        left_drive_smart.set_velocity(velocity, PERCENT)  \n        right_drive_smart.set_velocity(velocity, PERCENT) \n\n        # if the error is positive, we need to keep moving\n        # if the error is negative, we are overshooting and we need to reverse the movement direction\n        if error > 0:  \n            #print(\"Positive\")  \n            left_drive_smart.spin(REVERSE)  \n            right_drive_smart.spin(FORWARD)   \n        else:  \n            #print(\"Negative\")  \n            left_drive_smart.spin(FORWARD)  \n            right_drive_smart.spin(REVERSE)  \n    \n        # update the yaw error\n        error = yaw - brain_inertial.rotation()  \n        # wait for 10 ms before the next iteration to allow the gyro to refresh the value\n        wait(10, MSEC)  \n\n    print(\"gyro rotation: \" + str(brain_inertial.rotation()))\n    print(\"error: \" + str(error))   \n    print(\"done\")  \n    left_drive_smart.stop()  \n    right_drive_smart.stop()\n","textLanguage":"python","robotConfig":[{"port":[9],"name":"left_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[3],"name":"right_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":3,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.0.5","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false}